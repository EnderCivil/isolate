<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Isolate — V2.0</title>
<style>
  :root{
    --bg:#071023; --panel:#0b1220; --card:#0f1728; --muted:#98a0b3; --accent:#7dd3fc;
    --danger:#ff6b6b; --good:#7ef7a1; --glass: rgba(255,255,255,0.03);
    --card-radius:12px;
  }
  html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(180deg,#031026 0%, #061228 100%); color:#e6eef8; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  .app { display:grid; grid-template-columns: 1fr 360px; gap:14px; height:100vh; padding:18px; box-sizing:border-box; }
  @media (max-width:900px){ .app{ grid-template-columns: 1fr; grid-auto-rows: auto; padding:12px } #right { order:2 } #left { order:1 } }

  /* Left area */
  #left { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:var(--card-radius); padding:16px; overflow:auto; box-shadow: 0 10px 30px rgba(2,6,23,0.6); }
  #header { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px; }
  h1 { margin:0; font-size:18px; letter-spacing:0.2px; }
  .muted { color:var(--muted); font-size:13px; }

  /* Config / Game controls */
  .panel { background:var(--card); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02); margin-bottom:12px; }
  label{ display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }
  input[type=text], select, button { font-size:14px; }
  input[type=text], select { width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; }
  .row { display:flex; gap:8px; align-items:center; }
  .btn { background:var(--accent); color:#042029; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
  .btn.ghost { background:transparent; color:var(--accent); border:1px solid rgba(255,255,255,0.04); font-weight:600; }
  .small { font-size:13px; padding:6px 8px; border-radius:8px; }

  /* cards area */
  #cards { display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap:12px; margin-top:12px; }
  .card { background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.03); position:relative; min-height:120px; }
  .card.snapped { border-color: rgba(255,80,80,0.35); box-shadow:0 8px 20px rgba(255,40,40,0.05); background:linear-gradient(180deg, rgba(120,20,20,0.05), rgba(12,8,8,0.02)); }
  .card.dead { opacity:0.55; filter:grayscale(20%); text-decoration:line-through; }
  .card h3 { margin:0; font-size:16px; }
  .stats { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; font-size:13px; }
  .stat { background:var(--glass); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); min-width:78px; text-align:center; }

  .attr-list { margin-top:8px; font-size:13px; max-height:120px; overflow:auto; }
  .lastAction { margin-top:8px; font-style:italic; color:var(--muted); font-size:13px; min-height:30px; }

  /* Right-side log (fixed 30%) */
  #right { background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); padding:12px; border-radius:var(--card-radius); border:1px solid rgba(255,255,255,0.02); overflow:auto; position:relative; }
  #log { max-height:calc(100vh - 120px); overflow:auto; padding-right:8px; }
  .log-item { padding:8px 6px; border-bottom:1px dashed rgba(255,255,255,0.02); font-size:13px; color:var(--muted); }
  .ts { color:var(--muted); font-size:12px; margin-right:8px; }

  /* footer small */
  .mini { font-size:12px; color:var(--muted); }

  /* lobby grid */
  .lobby-grid { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }

  /* responsive tweaks */
  @media (max-width:900px){
    .card { min-height:100px; }
    #right{ order:2; height:auto; max-height:350px; }
  }
</style>
</head>
<body>
  <div class="app">
    <div id="left">
      <div id="header">
        <div>
          <h1>Isolate — V2.0</h1>
          <div class="muted">A social survival simulation</div>
        </div>
        <div style="text-align:right">
          <div class="mini">Helpline (display only): <strong>116 123</strong></div>
          <div class="mini muted">Disclaimer: Fictional. If distressed seek help.</div>
        </div>
      </div>

      <!-- Config panel -->
      <div class="panel" id="configPanel">
        <div style="display:flex; gap:12px; align-items:center;">
          <div style="flex:1;">
            <label for="nameInput">Name</label>
            <input id="nameInput" placeholder="e.g. Thomas" />
          </div>

          <div style="width:180px;">
            <label for="preset">Relationship with...</label>
            <select id="relationshipSelect"><option value="none">No relation</option></select>
          </div>

          <div style="width:140px;">
            <label for="relationshipType">Type</label>
            <select id="relationshipType">
              <option value="none">None</option>
              <option value="sibling">Sibling</option>
              <option value="spouse">Spouse</option>
            </select>
          </div>

          <div style="width:120px; display:flex; align-items:end;">
            <button class="btn" id="addBtn">Add</button>
          </div>
        </div>

        <div style="display:flex; gap:8px; margin-top:10px; align-items:center;">
          <div style="flex:1;">
            <label for="lobbySize">Pre-generated lobby</label>
            <select id="lobbySize">
              <option value="0">Choose size...</option>
              <option value="6">6 players (small)</option>
              <option value="12">12 players (regular)</option>
              <option value="24">24 players (party)</option>
              <option value="48">48 players (large)</option>
            </select>
          </div>
          <div style="width:140px;">
            <label>&nbsp;</label>
            <button class="btn" id="genLobby">Generate</button>
          </div>
          <div style="width:120px;">
            <label>&nbsp;</label>
            <button class="btn ghost" id="startGameBtn">Start Game</button>
          </div>
        </div>

        <div class="muted mini" style="margin-top:8px;">Add people or generate a lobby, add relationships, then start. Spouses never ask one another out; siblings rarely do (and get auto-rejection).</div>

        <div id="peopleConfigList" style="margin-top:12px;"></div>
      </div>

      <!-- Game panel -->
      <div class="panel" id="gamePanel" style="display:none;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <strong>Game</strong><div class="muted mini">Press New Turn to progress</div>
          </div>
          <div style="display:flex; gap:8px;">
            <button class="btn" id="turnBtn">New Turn</button>
            <button class="btn ghost" id="backBtn">Back to Config</button>
          </div>
        </div>
        <div id="cards"></div>
      </div>

    </div>

    <!-- Right side log -->
    <div id="right">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h3 style="margin:0">Event Log</h3>
        <div class="mini muted">Real-time narrative</div>
      </div>
      <div id="log" style="margin-top:8px;"></div>
    </div>
  </div>

<script>
/* =========================
   Isolate V2.0 — Single file
   ========================= */

/* ---------- Name pool (first names only) ---------- */
/* The user provided a long list — we use first names extracted from that list. */
const NAME_POOL = [
"Livia","Korbyn","Kimber","Kamryn","Laylani","Pierce","Anna","Graysen","Haylee","Jaxen","Madeline","George","Emmalyn","Tristan","Legacy","Kylen","Kayla","Lennox","Sophia","Maximiliano","Audrey","Alonso","Etta","Dax","Valentina","Killian","Emely","Cillian","Katherine","Dakari","Adelaide","Genesis","Anya","Callahan","Gabriela","Amos","Ivy","Casen","Sabrina","Dakota","Dahlia","Joaquin","Belle","Sebastian","Journee","Santana","Shay","Benjamin","Danna","Jake","Artemis","Dominick","Erin","Sean","Remy","Makai","Delaney","Max","Sylvie","Archie","Rory","Enrique","Elaine","Kole","Ellianna","Jamal","Kennedi","Carlos","Emory","Rhys","Madilynn","Phillip","Oakley","Aziel","Melissa","Myles","Addilynn","Will","Janiyah","Royal","Emerald","Chaim","Julissa","Bronson","Corinne","Bridger","Jennifer","Chris","Mia","Levi","Kylee","Oscar","Ariana","Kaison","Jaelynn","Roman","Alice","Kyng","Heidi","Westley","Itzel","Cal","Julieta","Kyle","Aubrie","Rayden","Audrey","Kameron","Hailey","Rex","Joyce","Grey","Genesis","Adler","Jennifer","Kenneth","Melody","Dane","Martha","Zane","Danielle","Ian","Alexia","Maurice","Jacqueline","Cain","Katalina","August","Marisol","Morgan","Imani","Maximiliano","Angelina","Charles","Hadlee","Rene","Oakley","Jakari","Adele","Ermias","Jocelyn","Danny","Jaylah","Sullivan","Renata","Kamden","Rory","Nasir","Treasure","Riley","Louisa","Luciano","Avah","Jad","Sara","Oakley","Diana","Nico","Ava","Justin","River","Kyler","Phoebe","Blake","Emmy","Marcellus","Queen","Sebastian","Regina","Kohen","Adeline","Enzo","Emmie","Eduardo","Winnie","Alessandro","Jayda","Bo","Aitana","Felipe","Shay","Raylan","Poppy","Wilson","Katalina","Azrael","Kallie","Alec","Sevyn","Ryland","Isabelle","Kye","Ashlyn","Jude","Amber","Harley","Celine","Leif","Lara","Lionel","Gracelyn","Chase","Khloe","Scott","Liliana","Luca","Christina","Harrison","Anika","Bryan","Cassidy","Robin","Angelina","Ocean","Ainsley","Moises","Deborah","Aries","Rivka","Dalton","Peyton","Emery","Bristol","Stetson","Josephine","Mohammad","Aya","Zaire","Anya","Tristan","Navy","Kane","Remy","Jasper","Emmalynn","Joshua","Virginia","Jayce","Frankie","Braden","Eileen","Zahir","Maisie","Paxton","Amayah","Israel","Rylie","Karson","Jaylah","Lukas","Clarissa","Eliezer","Maia","Riggs","Emmalynn","Quincy","Valerie","Pablo","Mackenzie","Edison","Ryann","Uriah","Leanna","Justin","Lauryn","Alfredo","Amelia","Alonso","Lucy","Keaton","Zaria","Kannon","Rachel","Samir","Emmalynn","Sterling","Julissa","Clayton","Rylan","Sutton","Armani","Douglas","Winter","Major","Jaylah","Jaxtyn","Margot","Peter","Aspen","Trey","Michelle","Paxton","Addison","Azariah","Kaylee","Curtis","Morgan","Nixon","Lexie","Zaiden","Rosalie","Bellamy","Harlee","Creed","Emersyn","Edward","Vienna","Arian","Zariah","Otis","Marley","Cayde"
];

/* ---------- State ---------- */
let people = []; // list of person objects
let turnCount = 0;

/* Person model:
{
  id, name,
  insanity (0-100),
  sad (0-100),
  sociopath (0-100),
  suicidal (bool),
  health (0-100),
  alive (bool),
  snapped (bool),
  weapon: {id,name,effectiveness} | null, // weapons only: knife/fork/spoon/gun
  items: array (e.g., ["rope"]),
  siblings: [ids],
  spouse: id|null,
  attraction: { otherId: percent },
  lastAction: string
}
*/

/* ---------- Weapon & item sets ---------- */
const WEAPONS = [
  { id:'knife', name:'Knife', effectiveness:0.80 },
  { id:'fork', name:'Fork', effectiveness:0.40 },
  { id:'spoon', name:'Spoon', effectiveness:0.20 },
  { id:'gun', name:'Gun', effectiveness:1.00 }
];
// Rope as a non-weapon utility item (used for hanging or execution)
const ITEM_ROPE = 'Rope';

/* ---------- DOM ---------- */
const peopleConfigList = document.getElementById('peopleConfigList');
const relationshipSelect = document.getElementById('relationshipSelect');
const relationshipType = document.getElementById('relationshipType');
const addBtn = document.getElementById('addBtn');
const nameInput = document.getElementById('nameInput');
const lobbySize = document.getElementById('lobbySize');
const genLobby = document.getElementById('genLobby');
const startGameBtn = document.getElementById('startGameBtn');
const cardsWrap = document.getElementById('cards');
const gamePanel = document.getElementById('gamePanel');
const configPanel = document.getElementById('configPanel');
const turnBtn = document.getElementById('turnBtn');
const backBtn = document.getElementById('backBtn');
const logEl = document.getElementById('log');

/* ---------- Utility helpers ---------- */
function nowTS() { return new Date().toLocaleTimeString(); }
function addLog(text) {
  const div = document.createElement('div');
  div.className = 'log-item';
  div.innerHTML = `<span class="ts">${nowTS()}</span> <span>${text}</span>`;
  logEl.prepend(div);
}
function rand(n){ return Math.random() < n; }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function joinNames(arr){
  if(arr.length===0) return '';
  if(arr.length===1) return arr[0];
  if(arr.length===2) return arr[0] + ' and ' + arr[1];
  return arr.slice(0,-1).join(', ') + ', and ' + arr[arr.length-1];
}
function findPerson(id){ return people.find(p=>p.id===id); }

/* ---------- Render config list ---------- */
function refreshRelationshipDropdown(){
  relationshipSelect.innerHTML = `<option value="none">No relation</option>`;
  people.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p.id;
    opt.textContent = p.name;
    relationshipSelect.appendChild(opt);
  });
}
function renderConfigList(){
  peopleConfigList.innerHTML = '';
  people.forEach(p=>{
    const div = document.createElement('div');
    div.className = 'panel';
    div.style.display = 'flex';
    div.style.justifyContent = 'space-between';
    div.style.alignItems = 'center';
    div.innerHTML = `
      <div>
        <strong>${p.name}</strong>
        <div class="mini muted">Insanity ${p.insanity}% • Sad ${p.sad}% • Health ${p.health}%</div>
        <div class="mini muted">Siblings: ${p.siblings.map(id=>findPerson(id)?.name||'').join(', ') || '—'} • Spouse: ${p.spouse ? (findPerson(p.spouse)?.name||'') : '—'}</div>
      </div>
      <div style="display:flex; flex-direction:column; gap:6px; align-items:flex-end;">
        <div>
          <button class="small ghost" data-id="${p.id}" data-act="remove">Remove</button>
        </div>
      </div>
    `;
    peopleConfigList.appendChild(div);
  });

  // attach remove handlers
  peopleConfigList.querySelectorAll('[data-act="remove"]').forEach(btn=>{
    btn.onclick = ()=>{
      const id = Number(btn.dataset.id);
      people = people.filter(x=>x.id!==id);
      // clean relationships referencing removed id
      people.forEach(p=>{
        p.siblings = p.siblings.filter(sid => sid !== id);
        if(p.spouse === id) p.spouse = null;
        delete p.attraction[id];
      });
      refreshRelationshipDropdown();
      renderConfigList();
    };
  });
}

/* ---------- Adding people & relationships ---------- */
let nextId = 1;
addBtn.onclick = ()=>{
  const name = nameInput.value.trim() || randChoice(NAME_POOL);
  const relTo = relationshipSelect.value;
  const relType = relationshipType.value;
  const p = {
    id: nextId++,
    name,
    insanity: 10 + Math.floor(Math.random()*6), // 10-15 baseline
    sad: Math.floor(Math.random()*10),
    sociopath: Math.floor(Math.random()*20),
    suicidal: false,
    health: 100,
    alive: true,
    snapped: false,
    weapon: null,
    items: [], // may contain Rope
    siblings: [],
    spouse: null,
    attraction: {},
    lastAction: "Awaiting the day..."
  };
  // add to list
  people.push(p);

  // apply relationship if chosen
  if(relTo !== 'none' && relType !== 'none'){
    const target = findPerson(Number(relTo));
    if(target){
      if(relType === 'sibling'){
        // mutual
        p.siblings.push(target.id);
        target.siblings.push(p.id);
      } else if(relType === 'spouse'){
        // set spouse if free
        if(!target.spouse){
          p.spouse = target.id;
          target.spouse = p.id;
        } else {
          // spouse occupied — just fall back to none
        }
      }
    }
  }

  refreshRelationshipDropdown();
  renderConfigList();
  nameInput.value = '';
};

/* ---------- Pre-generated lobby ---------- */
genLobby.onclick = ()=>{
  const size = Number(lobbySize.value);
  if(!size || size <= 0) { alert('Pick a lobby size'); return; }
  // clear current
  people = [];
  nextId = 1;
  // pick random unique first names
  const pool = NAME_POOL.slice();
  for(let i=0;i<size;i++){
    const idx = Math.floor(Math.random()*pool.length);
    const name = pool.splice(idx,1)[0] || (`Person ${i+1}`);
    const p = {
      id: nextId++,
      name,
      insanity: 10 + Math.floor(Math.random()*10),
      sad: Math.floor(Math.random()*12),
      sociopath: Math.floor(Math.random()*20),
      suicidal: false,
      health: 100,
      alive: true,
      snapped: false,
      weapon: null,
      items: [],
      siblings: [],
      spouse: null,
      attraction: {},
      lastAction: "Ready."
    };
    people.push(p);
  }

  // randomly add some relationships (small chance)
  // pair some spouses
  const poolIds = people.map(p=>p.id);
  for(let i=0;i<Math.floor(size/8); i++){
    const a = randChoice(poolIds), b = randChoice(poolIds);
    if(a !== b){
      const pa = findPerson(a), pb = findPerson(b);
      if(pa && pb && !pa.spouse && !pb.spouse){
        pa.spouse = pb.id; pb.spouse = pa.id;
      }
    }
  }
  // random sibling groups of size 2-3
  for(let i=0;i<Math.floor(size/6); i++){
    const a = randChoice(poolIds), b = randChoice(poolIds);
    if(a!==b){
      const pa = findPerson(a), pb = findPerson(b);
      if(pa && pb && !pa.siblings.includes(pb.id)){
        pa.siblings.push(pb.id); pb.siblings.push(pa.id);
      }
    }
  }

  refreshRelationshipDropdown();
  renderConfigList();
};

/* ---------- Start game: initialize attractions and UI ---------- */
startGameBtn.onclick = ()=>{
  if(people.length < 1) { alert('Add at least one person or generate a lobby.'); return; }
  // initialize attraction matrix: small random base
  const ids = people.map(p=>p.id);
  people.forEach(p=>{
    p.attraction = {};
    ids.forEach(id=>{
      if(id === p.id) return;
      // siblings slightly higher baseline affinity or variable? We'll set small.
      let base = Math.floor(Math.random()*20); // 0-19
      // spouses start with high attraction (love)
      if(p.spouse === id) base = 60 + Math.floor(Math.random()*25);
      // siblings will have low romantic attraction randomly negative stronger aversion
      if(p.siblings.includes(id)){
        // far less likely to ask; attraction small or small negative
        base = Math.floor(Math.random()*6) - Math.floor(Math.random()*6); // -5..5
      }
      p.attraction[id] = base;
    });
    p.alive = true; p.health = 100; p.snapped = false; p.weapon = null; p.items = p.items || [];
    p.suicidal = false;
    p.lastAction = "The day begins.";
  });

  // UI toggle
  configPanel.style.display = 'none';
  gamePanel.style.display = 'block';
  turnCount = 0;
  renderCards();
  addLog('Simulation started.');
};

/* ---------- Render cards ---------- */
function renderCards(){
  cardsWrap.innerHTML = '';
  people.forEach(p=>{
    const div = document.createElement('div');
    div.className = 'card' + (p.snapped ? ' snapped' : '') + (p.alive? '' : ' dead');
    // attributes summary
    let weaponsText = p.weapon ? `${p.weapon.name}` : (p.items.includes(ITEM_ROPE) ? `Has ${ITEM_ROPE}` : '—');
    // build attraction list (top 4)
    const attrEntries = Object.entries(p.attraction || {}).sort((a,b)=>b[1]-a[1]).slice(0,6);
    let attrHtml = '<div class="attr-list">';
    if(attrEntries.length === 0) attrHtml += `<div class="mini muted">No others</div>`;
    attrEntries.forEach(([id,v])=>{
      const other = findPerson(Number(id));
      if(!other) return;
      attrHtml += `<div><strong>${other.name}</strong>: ${v}%</div>`;
    });
    attrHtml += '</div>';

    div.innerHTML = `
      <h3>${p.name} ${p.snapped ? '<span style="color:var(--danger); font-weight:700">[SNAPPED]</span>':''} ${!p.alive?'<span class="muted">[DEAD]</span>':''}</h3>
      <div class="stats">
        <div class="stat">Health<br><strong>${p.health}</strong></div>
        <div class="stat">Insanity<br><strong>${p.insanity}%</strong></div>
        <div class="stat">Sad<br><strong>${p.sad}%</strong></div>
        <div class="stat">Sociopath<br><strong>${p.sociopath}%</strong></div>
      </div>
      <div style="margin-top:8px;">
        <div class="mini muted">Weapon / Items</div>
        <div class="mini">${weaponsText}</div>
      </div>
      ${attrHtml}
      <div class="lastAction">${p.lastAction || ''}</div>
    `;
    cardsWrap.appendChild(div);
  });
}

/* ---------- Core Turn Logic ---------- */
/* Balanced pacing, narrative text */

turnBtn.onclick = ()=> {
  advanceTurn();
  renderCards();
  checkEnd();
};

backBtn.onclick = ()=>{
  // go back to config
  configPanel.style.display = 'block';
  gamePanel.style.display = 'none';
};

/* helper to set last action for person and also add to log optionally */
function noteAction(p, text, logIt=true){
  p.lastAction = text;
  if(logIt) addLog(text);
}

/* Spread rumor and adjust attraction */
function spreadRumorAbout(attackerId, victimId, severity){
  // severity: "kill" or "attack" - larger effect for kill
  const witnesses = people.filter(x=>x.alive && x.id !== attackerId && x.id !== victimId);
  const sample = witnesses.sort(()=>0.5-Math.random()).slice(0, Math.min(4, witnesses.length));
  sample.forEach(w=>{
    const change = severity === 'kill' ? -40 : -20;
    w.attraction[attackerId] = clamp((w.attraction[attackerId]||0) + change, -200, 200);
    noteAction(w, `${w.name} heard news about ${findPerson(attackerId).name} - opinion worsened.`, false);
  });
}

/* Conversation routine: two people talk -> slight attraction change, mood shift */
function conversation(a,b){
  // narrative style: generate a sentence
  const topicSeed = Math.random();
  let outcomeText = '';
  let delta = 0;
  if(topicSeed < 0.45){
    // pleasant conversation
    delta = Math.floor(4 + Math.random()*6); // +4..10
    a.attraction[b.id] = clamp((a.attraction[b.id]||0) + delta, -200, 200);
    b.attraction[a.id] = clamp((b.attraction[a.id]||0) + Math.floor(delta/2), -200, 200); // reciprocation smaller
    // mood effects
    a.sad = clamp(a.sad - 3, 0, 100);
    b.sad = clamp(b.sad - 2, 0, 100);
    outcomeText = `${a.name} chatted with ${b.name}. The chat was warm — ${a.name}'s feelings toward ${b.name} rose by ${delta}%.`;
  } else if(topicSeed < 0.85){
    // neutral slight shifts
    delta = Math.floor(Math.random()*3) - 1; // -1..1
    a.attraction[b.id] = clamp((a.attraction[b.id]||0) + delta, -200, 200);
    b.attraction[a.id] = clamp((b.attraction[a.id]||0) - delta, -200, 200);
    outcomeText = `${a.name} and ${b.name} exchanged a few words; it left little mark on their feelings.`;
  } else {
    // bad conversation -> small negative
    delta = Math.floor(4 + Math.random()*6);
    a.attraction[b.id] = clamp((a.attraction[b.id]||0) - delta, -200, 200);
    b.sad = clamp(b.sad + 3, 0, 100);
    outcomeText = `${a.name} and ${b.name} argued over something trivial. ${a.name}'s attraction to ${b.name} fell by ${delta}%.`;
  }
  noteAction(a, outcomeText);
}

/* Attempt suicide: choose method and resolve */
function attemptSuicide(p){
  // choose method: if has rope -> hanging, if gun -> gun, else choose from balcony/drown/overdose
  // methods and their success odds per spec
  const hasGun = p.weapon && p.weapon.id === 'gun';
  const hasRope = p.items.includes(ITEM_ROPE);
  if(hasGun){
    p.alive = false; p.health = 0;
    addLog(`${p.name} shot themselves. They died.`);
    return;
  }
  if(hasRope){
    p.alive = false; p.health = 0;
    addLog(`${p.name} hung themselves. They died.`);
    return;
  }
  // try balcony (50%), drown (80%), overdose (100%), slit throat with small weapon if have knife (80%)
  const methods = [];
  methods.push({id:'balcony', chance:0.5, successText:'found a balcony and threw themselves off it', failText:'They were hardly injured.'});
  methods.push({id:'drown', chance:0.8, successText:'sunk themselves into the water', failText:'They struggled but survived.'});
  methods.push({id:'overdose', chance:1.0, successText:'overdosed, seemingly on purpose', failText:''});
  if(p.weapon && p.weapon.id === 'knife') methods.push({id:'knife', chance:0.8, successText:`slit their throat with a ${p.weapon.name}`, failText:'They survived the attempt.'});
  const choice = randChoice(methods);
  if(Math.random() < choice.chance){
    p.alive = false; p.health = 0;
    addLog(`${p.name} ${choice.successText}.`);
  } else {
    p.health = Math.max(5, p.health - 30);
    addLog(`${p.name} attempted suicide (${choice.id}) but survived. ${choice.failText}`);
    p.suicidal = true;
  }
}

/* Attack routine for single attacker */
function singleAttack(attacker, victim){
  if(!victim.alive) return;
  // choose method: if attacker has weapon (knife/fork/gun/spoon) use it; else fists
  if(attacker.weapon){
    const w = attacker.weapon;
    const success = Math.random() < w.effectiveness;
    if(success){
      // victim dies
      victim.alive = false; victim.health = 0;
      // phrasing: avoid rope as weapon
      addLog(`${attacker.name} attacked ${victim.name} with a ${w.name}. ${victim.name} died from their injuries.`);
      noteAction(attacker, `${attacker.name} killed ${victim.name} with a ${w.name}.`);
      spreadRumorAbout(attacker.id, victim.id, 'kill');
    } else {
      victim.health = Math.max(40, victim.health - Math.floor(15 + Math.random()*20));
      addLog(`${attacker.name} attacked ${victim.name} with a ${w.name}, but ${victim.name} escaped injured (health ${victim.health}).`);
      noteAction(attacker, `${attacker.name} attempted to kill ${victim.name} with a ${w.name} but failed.`);
      spreadRumorAbout(attacker.id, victim.id, 'attack');
      // survivors' attraction to attacker becomes strongly negative
      victim.attraction[attacker.id] = -100;
    }
  } else {
    // fists style attack
    const outcome = Math.random();
    if(outcome < 0.2){
      // kill by blunt trauma
      victim.alive = false; victim.health = 0;
      addLog(`${attacker.name} beat ${victim.name} mercilessly. ${victim.name} bled out.`);
      noteAction(attacker, `${attacker.name} killed ${victim.name} by beating.`);
      spreadRumorAbout(attacker.id, victim.id, 'kill');
    } else if(outcome < 0.6){
      victim.health = Math.max(30, victim.health - Math.floor(20 + Math.random()*30));
      addLog(`${attacker.name} attacked ${victim.name} and left them injured (health ${victim.health}).`);
      noteAction(attacker, `${attacker.name} attacked ${victim.name} with fists.`);
      spreadRumorAbout(attacker.id, victim.id, 'attack');
      victim.attraction[attacker.id] = -100;
    } else {
      addLog(`${attacker.name} lunged at ${victim.name} but failed to land a decisive blow.`);
      noteAction(attacker, `${attacker.name} attempted an attack but failed.`);
    }
  }
}

/* Group attack & execution planning */
function planGroupActions(){
  // find targets with multiple people who strongly dislike them
  const aliveList = people.filter(p=>p.alive);
  aliveList.forEach(target=>{
    // count haters: those with attraction[target.id] <= -75
    const haters = people.filter(p=>p.alive && (p.attraction[target.id]||0) <= -75 && p.id !== target.id);
    if(haters.length >= 3){
      // high hate -> plan execution with chance across turns
      // create a plannedAttack object on haters (we'll execute immediately with some prob)
      if(Math.random() < 0.25){ // 25% chance per turn to move from gossip->plan->attack
        executeGroupKill(haters, target);
      } else if(Math.random() < 0.5) {
        // gossip about target
        addLog(`${joinNames(haters.map(h=>h.name))} were heard gossiping viciously about ${target.name}.`);
        haters.forEach(h=>{
          noteAction(h, `Gossiped about ${target.name}.`, false);
        });
      }
    } else if(haters.length >= 2){
      // smaller group might gang up and beat (non-lethal)
      if(Math.random() < 0.20){
        executeGroupBeat(haters, target);
      } else if(Math.random() < 0.4){
        addLog(`${joinNames(haters.map(h=>h.name))} whispered mean things about ${target.name}.`);
        haters.forEach(h=> noteAction(h, `Said mean things about ${target.name}.`, false));
      }
    }
  });
}

/* Group beat (non-lethal) */
function executeGroupBeat(group, victim){
  const names = joinNames(group.map(g=>g.name));
  addLog(`${names} all beat up ${victim.name}.`);
  noteAction(victim, `${victim.name} was beaten by ${names}.`);
  victim.health = Math.max(10, victim.health - Math.floor(30 + Math.random()*30));
  // increase sadness for victim
  victim.sad = clamp(victim.sad + 20, 0, 100);
  // the group gains a small injudicious bond (they feel more united)
  group.forEach(g => {
    g.sociopath = clamp(g.sociopath + 3, 0, 100);
  });
}

/* Group kill (execution-style) */
function executeGroupKill(group, victim){
  // Decide execution method: hanging if any rope owner in group, otherwise brutal murder with weapons if available
  const names = group.map(g=>g.name);
  const namesText = joinNames(names);
  const groupWeaponList = group.map(g=>g.weapon).filter(Boolean);
  const anyRope = group.some(g=>g.items.includes(ITEM_ROPE));
  if(anyRope){
    // hang them
    victim.alive = false; victim.health = 0;
    addLog(`${namesText} captured ${victim.name} and hung them from the roof, like a sort of execution.`);
    noteAction(victim, `${victim.name} was executed by hanging.`);
    spreadRumorAbout(group[0].id, victim.id, 'kill'); // general rumor effect
  } else if(groupWeaponList.length > 0){
    // use the group's weapons (plural) to torture and kill
    const weaponNames = groupWeaponList.map(w=>w.name).join(', ');
    victim.alive = false; victim.health = 0;
    addLog(`${namesText} captured ${victim.name} and tortured them with ${weaponNames}. They died from the blood loss.`);
    noteAction(victim, `${victim.name} was tortured and killed by ${namesText}.`);
    spreadRumorAbout(group[0].id, victim.id, 'kill');
  } else {
    // no weapons and no rope -> brutal group beating leading to death
    victim.alive = false; victim.health = 0;
    addLog(`${namesText} captured ${victim.name} and beat them until they died.`);
    noteAction(victim, `${victim.name} was killed by a group attack.`);
    spreadRumorAbout(group[0].id, victim.id, 'kill');
  }
}

/* Main advanceTurn: balanced pacing */
function advanceTurn(){
  turnCount++;
  addLog(`--- Turn ${turnCount} ---`);
  // baseline small drift
  people.forEach(p => {
    if(!p.alive) return;
    // passive stat drift
    p.insanity = clamp(p.insanity + (Math.random()*2 - 0.8), 0, 100);
    p.sad = clamp(p.sad + (Math.random()*2 - 0.6), 0, 100);
  });

  // 1) Conversations: choose some pairs (chance per alive pair) - ensure multiple convos can occur
  const alive = people.filter(p=>p.alive);
  const convoPairs = Math.max(1, Math.floor(alive.length / 3)); // Balanced: ~1 convo per 3 people
  for(let i=0;i<convoPairs;i++){
    const a = randChoice(alive);
    let b = randChoice(alive);
    let tries = 0;
    while(b.id === a.id && tries < 6){ b = randChoice(alive); tries++; }
    if(a.id === b.id) continue;
    // Prevent conversations spouses -> rarely very romantic; siblings less likely to ask out later but can converse
    conversation(a,b);
  }

  // 2) Snapping check (insanity/5 percent chance)
  const newlySnapped = [];
  alive.forEach(p=>{
    if(p.snapped || !p.alive) return;
    const chance = (p.insanity / 5) / 100; // insanity=55 => 0.11
    if(Math.random() < chance){
      p.snapped = true;
      newlySnapped.push(p);
      addLog(`${p.name} has snapped. Their behavior turns violent.`);
      noteAction(p, `${p.name} snapped and seems dangerous.`);
    }
  });

  // 3) Snapped behavior: find weapon/item and attack 1-2 targets
  const snappedNow = people.filter(p => p.alive && p.snapped);
  snappedNow.forEach(attacker=>{
    // if no weapon, 80% chance to find one, 30% chance to find rope as item
    if(!attacker.weapon && !attacker.items.includes(ITEM_ROPE)){
      if(Math.random() < 0.8){
        const w = randChoice(WEAPONS);
        attacker.weapon = {...w};
        noteAction(attacker, `${attacker.name} found a ${w.name}.`);
        addLog(`${attacker.name} found a ${w.name}.`);
      } else if(Math.random() < 0.3){
        attacker.items.push(ITEM_ROPE);
        noteAction(attacker, `${attacker.name} found a length of rope.`);
        addLog(`${attacker.name} found a length of rope.`);
      }
    }
    const attacks = Math.random() < 0.45 ? 2 : 1;
    for(let i=0;i<attacks;i++){
      const targets = people.filter(t=>t.alive && t.id !== attacker.id);
      if(targets.length === 0) break;
      const target = randChoice(targets);
      singleAttack(attacker, target);
    }
  });

  // 4) Non-snapped may ask out (based on attraction) and talk more: This is separate from conversations above
  alive.forEach(p=>{
    if(!p.alive || p.snapped) return;
    // For each target, small chance to ask out based on attraction value (percent)
    const keys = Object.keys(p.attraction || {});
    keys.forEach(k=>{
      const val = p.attraction[k];
      if(val <= 0) return; // only positive attraction leads to asking
      const target = findPerson(Number(k));
      if(!target || !target.alive) return;
      // reduce asking chance if siblings/spouse
      if(p.siblings.includes(target.id)) return; // siblings won't ask
      if(p.spouse === target.id) return; // spouses never ask
      const askChance = clamp(val/100, 0, 1);
      if(Math.random() < askChance * 0.06){ // tuned small chance each turn
        // Ask out
        const acceptChance = clamp(((target.attraction[p.id]||0) * 2) / 100, 0, 1);
        if(Math.random() < acceptChance){
          p.attraction[target.id] = clamp(p.attraction[target.id] + 15, -200, 200);
          target.attraction[p.id] = clamp((target.attraction[p.id]||0) + 10, -200, 200);
          addLog(`${p.name} asked ${target.name} out. ${target.name} accepted.`);
          noteAction(p, `${p.name} and ${target.name} are getting closer.`);
        } else {
          // rejection consequences
          p.sad = clamp(p.sad + 75, 0, 100);
          addLog(`${p.name} asked ${target.name} out but was rejected. ${p.name} is devastated (+75 Sad).`);
          noteAction(p, `${p.name} was rejected by ${target.name}.`);
          // chance to become suicidal from sadness/4 per-turn
          const suicidalChance = clamp((p.sad / 4) / 100, 0, 1);
          if(!p.suicidal && Math.random() < suicidalChance){
            p.suicidal = true;
            addLog(`${p.name} is showing suicidal tendencies.`);
            noteAction(p, `${p.name} became suicidal.`);
          }
        }
      }
    });
  });

  // 5) Suicidal attempts: if suicidal true, attempt chance each turn grows with sad
  alive.forEach(p=>{
    if(!p.alive) return;
    if(p.suicidal){
      // attempt chance tuned: base 3% + sad% * 0.7% -> sadness 100 => ~70% + base = 73% (high)
      const attemptChance = clamp(0.03 + (p.sad * 0.007), 0, 0.95);
      if(Math.random() < attemptChance){
        noteAction(p, `${p.name} is attempting suicide...`);
        attemptSuicide(p);
      }
    } else {
      // chance to become suicidal from high sadness: sad/4 per turn
      const chanceToBecome = clamp((p.sad / 4) / 100, 0, 1);
      if(Math.random() < chanceToBecome){
        p.suicidal = true;
        addLog(`${p.name} has become suicidal.`);
        noteAction(p, `${p.name} became suicidal.`);
      }
    }
  });

  // 6) Group dynamics: gossip -> planned attacks -> executions
  planGroupActions();

  // 7) Talking reduces suicidal risk: some people may talk to suicidal person
  // For each suicidal person, 20% chance someone talks them down
  const suicidalOnes = people.filter(p => p.alive && p.suicidal);
  suicidalOnes.forEach(s=>{
    const others = people.filter(x=>x.alive && x.id !== s.id);
    if(others.length===0) return;
    if(Math.random() < 0.2){
      const talker = randChoice(others);
      // talking reduces sad by 20 points (or cancels suicidal if goes below 10)
      s.sad = clamp(s.sad - 20, 0, 100);
      if(s.sad <= 10){
        s.suicidal = false;
        s.sad = 5;
        addLog(`${talker.name} talked to ${s.name}. ${s.name}'s suicidal feelings decreased and they are no longer suicidal.`);
        noteAction(s, `${talker.name} helped them calm down.`);
      } else {
        addLog(`${talker.name} spoke with ${s.name} to comfort them. Sadness decreased a little.`);
        noteAction(s, `${talker.name} tried to comfort them.`);
      }
    }
  });

  // 8) Isolated: if someone is the only survivor, big jump in insanity/sad
  const aliveNow = people.filter(p=>p.alive);
  if(aliveNow.length === 1){
    const sole = aliveNow[0];
    sole.insanity = clamp(sole.insanity + 15, 0, 100);
    sole.sad = clamp(sole.sad + 20, 0, 100);
    addLog(`${sole.name} is alone. Insanity and Sadness rose sharply.`);
    noteAction(sole, `${sole.name} is alone and struggling.`);
  }

  // 9) small per-turn mutations and clear trivial lastActions if too old
  people.forEach(p=>{
    if(!p.alive) return;
    // decay small values
    p.insanity = clamp(p.insanity + (Math.random()*1 - 0.5), 0, 100);
    p.sad = clamp(p.sad + (Math.random()*1 - 0.5), 0, 100);
    // small chance to pick up a rope item randomly in environment (rare)
    if(Math.random() < 0.01 && !p.items.includes(ITEM_ROPE)) {
      p.items.push(ITEM_ROPE);
      addLog(`${p.name} found a rope lying around.`);
      noteAction(p, `${p.name} picked up a rope.`);
    }
    // small chance to drop weapon
    if(p.weapon && Math.random() < 0.02){
      addLog(`${p.name} dropped their ${p.weapon.name}.`);
      p.weapon = null;
    }
  });
}

/* ---------- End condition check ---------- */
function checkEnd(){
  const alive = people.filter(p=>p.alive);
  if(alive.length === 0){
    addLog('All characters are dead. Simulation ended.');
    alert('GAME OVER — All characters are dead. Check the log for details.');
    // return to config view
    gamePanel.style.display = 'none';
    configPanel.style.display = 'block';
  } else if(alive.length === 1){
    addLog(`${alive[0].name} is the last person alive.`);
  }
}

/* ---------- Initial UI hookup ---------- */
refreshRelationshipDropdown();
renderConfigList();
renderCards();

/* Expose some debug controls to console if needed */
window.IsolateSim = {
  people,
  addRandom: (n=6)=>{ lobbySize.value=n; genLobby.click(); },
  start: ()=> startGameBtn.click(),
  turn: ()=> turnBtn.click()
};

</script>
</body>
</html>
